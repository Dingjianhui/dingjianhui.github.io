[
    {
        "uri": "/posts/2020/06/05/gocrosscompile",
        "title": "windows 开发环境下 go 交叉编译",
        "content": "\n## linux\n    set GOOS=linux\n    set GOARCH=amd64\n    go build -o build/hugo main.go\n\n## windows\n    set GOOS=windows\n    set GOARCH=amd64\n    go buil",
        "tags": [
            "go",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/06/06/gostringsbyterune",
        "title": "Golang中string、byte、rune的区别",
        "content": "\n\n### 什么是string\n`string` 是不可变的字节序列,采用`utf8`编码的 `字节切片(slice)`,\n因此用`len`函数获取到的长度并不是字符个数，而是字节个数。\n`for`循环遍历输出的也是各个字节。\n```go\na := \"Randal\";\nfor i := 0; i ",
        "tags": [
            "go",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/06/11/etcdclusterbydocker",
        "title": "使用docker模拟etcd集群的创建",
        "content": "\n\n    实际中部署集群 使用不同机器 或 docker swarm  或 k8s  来部署\n\n## Step 1  创建一个专门的docker网络 \n\n    创建docker网络  (使用的是bridge,指定了子网)\n    docker network  create etcdnet  -",
        "tags": [
            "docker",
            "etcd"
        ]
    },
    {
        "uri": "/posts/2020/06/11/etcdinstall",
        "title": "etcd入门之环境搭建与命令使用(基于docker)",
        "content": "\n### etcd简介\n\n> A distributed, reliable key-value store for the most critical data of a distributed system\n\n    etcd是一个高可用的键值存储系统\n    etcd是由CoreOS开发并维护",
        "tags": [
            "docker",
            "etcd",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/06/17/centosdockerinstall",
        "title": "Centos 7系统中安装docker & Docker Compose",
        "content": "\n\n> 安装文档-以官方文档为准\n\n    官方文档\n    https://docs.docker.com/engine/install/centos/\n    \n## Step 1  卸载旧版本\n\n```shell script\n$ sudo yum remove docker \\\n      ",
        "tags": [
            "docker",
            "centos7"
        ]
    },
    {
        "uri": "/posts/2020/06/19/goetcdv3ServiceDiscovery",
        "title": "Go + Etcd V3 实现 服务注册与发现",
        "content": "\n \n## 示意图\n\n![avatar](/img/etcd_find.jpg)\n\n\n## 服务注册\n    \n    1.服务提供者  创建服务\n    2.服务提供者  配置etcd\n    3.服务提供者  把服务注册到配置的etcd中\n    4.服务启动\n    5.服务关闭时反注册服务 ",
        "tags": [
            "go",
            "etcd"
        ]
    },
    {
        "uri": "/posts/2020/06/24/gobinarysearchtree",
        "title": "使用Golang实现二叉查找树案例",
        "content": "\n\n# 二叉查找树(binary search tree)\n\n特征：\n\n二叉查找树，也称二叉搜索树，或二叉排序树。 要么是一颗空树，要么就是具有如下性质的二叉树：\n\n    （1） 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n    （2） 若任意节点的右子树不空，则右子树",
        "tags": [
            "二叉树",
            "go"
        ]
    },
    {
        "uri": "/posts/2020/06/24/godeferused",
        "title": "Golang中Defer的机制解读与defer的用法",
        "content": "\n\n## defer介绍\n\n关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 `return` 语句之后）一刻才执行某个语句或函数\n（为什么要在返回之后才执行这些语句？因为 `return` 语句同样可以包含一些操作，而不是单纯地返回某个值）。\n\n常用于释放某些已分配的资源、关闭数据库",
        "tags": [
            "defer",
            "go",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/06/26/goetcdsimpleconfigcenter",
        "title": "Golang + Etcd + Confd 实现简易的配置中心",
        "content": "\n## 简易示意图\n\n![avatar](/img/etcd_simple_config.jpg)\n\n## Confd简介\n    \n一款高可用统一配置管理工具(go写的)\n\n## Confd安装使用\n  \n### Step 1. 构建Confd镜像(使用go镜像)\n    \n```shell sc",
        "tags": [
            "etcd",
            "go"
        ]
    },
    {
        "uri": "/posts/2020/06/28/gogrpcquickstart",
        "title": "grpc的优势与安装使用-Golang",
        "content": "\n## 前言\n对于分布式系统而言,不同的服务分布在不同的节点上,一个服务要完成自己的功能经常需要调用其他服务的接口,比如典型的微服务架构。\n通常这种服务调用方式有两种,一种是`发送HTTP请求的方式`,另一种则是`RPC的方式`,RPC是`Remote Procedure Call`(远程过程调用)",
        "tags": [
            "go",
            "grpc",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/06/30/generatelocalcertificate",
        "title": "自签名https证书，本地浏览器测试",
        "content": "\n\nOpenSSL工具下载： [下载地址链接](http://slproweb.com/products/Win32OpenSSL.html)\n\n## windows环境\n\n### 自签证书\n\n进入 bin目录\n    \n1. 执行 `openssl.exe`\n\n2. 执行 `genrsa -des",
        "tags": [
            "https",
            "openssl"
        ]
    },
    {
        "uri": "/posts/2020/06/30/gogrpcgateway",
        "title": "使用grpc-gateway同时提供rpc和Restful接口-Golang",
        "content": "\n![原理图](/img/swgJWIrqqwzCAXWnWnUWH-g.png)\n\n## 前言\n\n`grpc`很棒-支持多种语言来构建`rpc`服务,`快速`、`易于使用`、`带宽高效`， \n但是我们仍然希望提供供传统的`RESTful JSON API`，兼容老系统\n\n通常我们把`rpc`用作内",
        "tags": [
            "go",
            "grpc",
            "gateway"
        ]
    },
    {
        "uri": "/posts/2020/07/01/protobufgrammar",
        "title": "Protobuf语法-常用语法 (Protobu3)",
        "content": "\n## 前言\n\n`Protobuf[1]` 是一种语言中立、平台无关、可扩展的序列化数据的格式，可用于通信协议，数据存储等。\n\n`ProtoBuf` 在序列化数据方面，它是灵活的、高效的。\n相比于 `XML` 来说，`ProtoBuf` 更加小巧、更加快速、更加简单。\n一旦定义了要处理的数据的数据结",
        "tags": [
            "protobuf",
            "grpc"
        ]
    },
    {
        "uri": "/posts/2020/07/03/gogrpcstream",
        "title": "流式RPC的使用例子(基于Golang)",
        "content": "\n官方文档(基于`golang`语言)\n\n流式RPC(服务端流式RPC、客户端流式RPC、双向流式RPC)\nhttps://www.grpc.io/docs/languages/go/basics\n\n官方案例： https://github.com/grpc/grpc-go/tree/master/",
        "tags": [
            "go",
            "grpc"
        ]
    },
    {
        "uri": "/posts/2020/07/07/goscheduler",
        "title": "Golang 中协程调度的简单理解",
        "content": "\n\n### 调度逻辑\n\n![avatar](/img/goroutine-scheduler-model.png)\n\n\n### 1. P、M、G的定义\n\n- P: `processor`(代表处理器核)，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数>=P的数量）；\nP的最大作",
        "tags": [
            "go",
            "协程",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/07/20/gostructdefaultvalue",
        "title": "Golang技巧之默认值设置的高阶玩法",
        "content": "\n传参时，不改变属性默认值时就不传该参数\n\n\n### 1. 普通玩法\n\n比如`php`中\n```php\n    public function addLog($log_type,$log_content,$admin_id,$admin_name,$type = 2)\n    {\n        .",
        "tags": [
            "go",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/07/21/gomap",
        "title": "Golang Map的使用案例--设置值、排序、多个map排序",
        "content": "\n### Map(集合)\n\n`Map` 是一种`无序`的`键值对`的`集合`\n\n### 定义初始化\n\n```go\n// 定义map\ntype (\n\tUserMap map[string]interface{}\n)\n\n// 初始化map\nfunc NewUser() UserMap {\n\treturn",
        "tags": [
            "go",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/07/22/gotest",
        "title": "Golang 测试用例的写法-单元测试、性能测试",
        "content": "\n## 简介\ngo 自带单元测试和性能测试模块，仅需要很少的代码就可以快速测试一段需求代码\n\n## 准则\n\n1. 需要创建一个名称以 `_test.go` 结尾的文件\n2. 该文件包含 测试用例 (如：`TestXxx` 函数)\n\n测试用例有四种形式：\n\n    TestXxxx(t *testin",
        "tags": [
            "go",
            "go测试",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/07/26/gotestmock",
        "title": "Golang 测试进阶之gomock框架(单元测试)",
        "content": "\n> 官方文档\n> \n> https://github.com/golang/mock\n>\n> https://godoc.org/github.com/golang/mock/gomock\n>\n\n## 介绍\n> GoMock is a mocking framework for the Go pr",
        "tags": [
            "go",
            "go测试"
        ]
    },
    {
        "uri": "/posts/2020/07/29/redissetsecurityoptions",
        "title": "Docker中安装Redis并设置安全选项",
        "content": "\n> 官方文档\n>\n> https://redis.io/\n>\n> https://hub.docker.com/_/redis\n>\n> https://github.com/redis/redis\n\n## 环境\nCentOS 7 + docker + docker-compose + redis ",
        "tags": [
            "docker",
            "redis",
            "安全",
            "docker-compose",
            "centos7"
        ]
    },
    {
        "uri": "/posts/2020/07/30/godefineenum",
        "title": "如何使用golang定义枚举",
        "content": "\n\n\n## 前言\n枚举就是一一列举，将所有的情况都列举出来，那么取值的时候只能是这几种情况的一种，不能是别的。\n\n`Golang` 中没有 `enum` 关键字，要定义枚举可以使用 const 配合 iota 常量生成器 来定义。\n\n1. `iota`是`Golang`语言的常量计数器,只能在常量的",
        "tags": [
            "go",
            "go初级"
        ]
    },
    {
        "uri": "/posts/2020/07/30/gogoroutinenum",
        "title": "限制协程执行数量的基本方法(防止机器跑崩)",
        "content": "\n## 介绍\n我们在开发过程中，如果不对Goroutine加以控制而进行滥用的话，\n可能会导致服务程序整体崩溃。\n\n## 实现代码\n使用类似数据库连接池，redis连接池的做法\n\n定义一个协程池，往协和池里塞入空值，协程池满后阻塞\n```go\npackage main\n\nimport (\n\t\"fmt",
        "tags": [
            "go",
            "go初级"
        ]
    }
]