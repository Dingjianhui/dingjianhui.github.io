<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Ding Jianhui 的个人博客 - 学习笔记</title>
    <link>http://dingjianhui.top/categories/golang/</link>
    <description>Recent content in golang on Ding Jianhui 的个人博客 - 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 30 Jun 2020 14:53:25 +0800</lastBuildDate>
    
	<atom:link href="http://dingjianhui.top/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Grpc Gateway</title>
      <link>http://dingjianhui.top/blog/2020/06/30/go-grpc-gateway/</link>
      <pubDate>Tue, 30 Jun 2020 14:53:25 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/30/go-grpc-gateway/</guid>
      <description>前言 grpc很棒-支持多种语言来构建rpc服务,快速、易于使用、带宽高效， 但是我们仍然希望提供供传统的RESTful JSON API，兼容老系统
通常我们把rpc用作内部通信，而使用RESTful Api进行外部通信
服务器收到Http请求后grpc-gateway把他转换成grpc处理，然后以JSON格式返回
安装  安装 Protocol buffer 编译器(protoc) V3版本 https://github.com/protocolbuffers/protobuf/releases 安装 Protocol buffer 编译器的 Go插件 (protoc-gen-go) go get github.com/golang/protobuf/protoc-gen-go 安装 Protocol buffer 编译器的插件-grpc-gateway go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway 安装 Protocol buffer 编译器的插件-swagger go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger  使用 1. 使用Protocol buffer定义gRPC服务 server/pbfiles/Prod.proto:  syntax=&amp;#34;proto3&amp;#34;;package services;message ProdRequest { int32 prod_id =1; //传入的商品ID }message ProdResponse{ int32 prod_stock=1;//商品库存 }service ProdService { rpc GetProdStock (ProdRequest) returns (ProdResponse);}2. 添加google.api.http annotation 到 *.proto 文件中 可以将文件拷至 server/pbfiles中，也可以引用外部资源的方式 server/pbfiles/Prod.</description>
    </item>
    
    <item>
      <title>Go Grpc Quick Start</title>
      <link>http://dingjianhui.top/blog/2020/06/28/go-grpc-quick-start/</link>
      <pubDate>Sun, 28 Jun 2020 13:47:36 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/28/go-grpc-quick-start/</guid>
      <description>对于分布式系统而言,不同的服务分布在不同的节点上,一个服务要完成自己的功能经常需要调用其他服务的接口,比如典型的微服务架构。 通常这种服务调用方式有两种,一种是发送HTTP请求的方式,另一种则是RPC的方式,RPC是Remote Procedure Call(远程过程调用)的简称, 可以让我们像调用本地接口一样使用远程服务。相比HTTP调用,RPC的方式至少在以下几个方面有优势
  传输效率
RPC可以自定义TCP报文,基于TCP协议进行通信,比如dubbo;同时也支持使用HTTP2协议进行通信,比如gRPC。这相比传统的HTTP1.1协议报文体积会更小,传输效率会更高。
  性能消耗
RPC框架通常自带高效的序列化机制,序列化和反序列化耗时更低,序列化后的字节数通常也更小。
  负载均衡
RPC框架通常自带负载均衡策略,而HTTP请求要做负载均衡需要外部应用如Nginx的支持。
  服务治理
下游服务新增,重启,下线时能自动通知上游使用者,而HTTP的方式需要事先通知并修改相关配置。
  grpc介绍 gRPC是由Google开发并开源的RPC框架,它具有以下特点
  语言中立
支持C,Java,Go等多种语言来构建RPC服务,这是gRPC被广泛的应用在微服务项目中的重要原因,因为不同的微服务可能用不同的语言构建。
  基于HTTP/2协议
支持双向流,消息头压缩,单TCP的多路复用,服务端推送等,这些特性使得gRPC更加适用于移动场景下的客户端和服务端之间的通信。
  基于IDL定义服务
编写.proto文件即可生成特定语言的数据结构、服务端接口和客户端Stub。
  支持Protocol Buffer序列化
Protocol Buffer是由Google开发的一种数据序列化协议(类似于XML、JSON、Hession),平台无关,压缩和传输效率高,语法简单,表达能力强。
  使用前的准备工作   安装go
  安装 Protocol buffer 编译器(protoc) V3版本 https://github.com/protocolbuffers/protobuf/releases
  安装 Protocol buffer 编译器的 Go插件 (protoc-gen-go) go get github.com/golang/protobuf/protoc-gen-go
Google Protocol Buffer( 简称 Protobuf)</description>
    </item>
    
    <item>
      <title>Go Etcd Simple Config Center</title>
      <link>http://dingjianhui.top/blog/2020/06/26/go-etcd-simple-config-center/</link>
      <pubDate>Fri, 26 Jun 2020 15:50:48 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/26/go-etcd-simple-config-center/</guid>
      <description>简易示意图 Confd 一款高可用统一配置管理工具(go写的)
Step 1. 构建Confd镜像(使用go镜像) [tintin@localhost ttphp]$ ls etcd etcds tools [tintin@localhost ttphp]$ mkdir build [tintin@localhost ttphp]$ mkdir build/confd [tintin@localhost ttphp]$ cd build/confd/ [tintin@localhost confd]$ vi Dockerfile Dockerfile 参考文档
https://github.com/kelseyhightower/confd/blob/master/docs/installation.md
FROM1.14.4-alpine3.12 as confdARG CONFD_VERSION=0.16.0ADD https://github.com/kelseyhightower/confd/archive/v${CONFD_VERSION}.tar.gz /tmp/RUN apk add --no-cache \  bzip2 \  make &amp;amp;&amp;amp; \  mkdir -p /go/src/github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  cd /go/src/github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  tar --strip-components=1 -zxf /tmp/v${CONFD_VERSION}.tar.gz &amp;amp;&amp;amp; \  go install github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  rm -rf /tmp/v${CONFD_VERSION}.</description>
    </item>
    
    <item>
      <title>Go Binary Search Tree</title>
      <link>http://dingjianhui.top/blog/2020/06/24/go-binary-search-tree/</link>
      <pubDate>Wed, 24 Jun 2020 18:04:15 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/24/go-binary-search-tree/</guid>
      <description>二叉查找树(binary search tree) 特征：
二叉查找树，也称二叉搜索树，或二叉排序树。 要么是一颗空树，要么就是具有如下性质的二叉树：
（1） 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； （2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； （3） 任意节点的左、右子树也分别为二叉查找树； （4） 没有值相等的节点  1. 动态创建节点 func AddNode(tree *BSTree, root *BSTree) *BSTree { if root == nil { return tree } // 根节点 与 新节点对比 	// 新节点比 根节点大 放入右节点 	// 新节点比 根节点小 放入左节点 	if tree.Node &amp;gt; root.Node { root.RightNode = AddNode(tree,root.RightNode) } else if tree.Node &amp;lt; root.Node { root.LeftNode = AddNode(tree,root.LeftNode) } else { return root } return root } 2.</description>
    </item>
    
    <item>
      <title>Go Defer 的使用</title>
      <link>http://dingjianhui.top/blog/2020/06/24/go-defer-used/</link>
      <pubDate>Wed, 24 Jun 2020 09:04:03 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/24/go-defer-used/</guid>
      <description>defer介绍 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数 （为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。
常用于释放某些已分配的资源、关闭数据库连接、断开Socket连接、解锁一个加锁的资源
关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。
三个简单的规则：
1.defer定义时,defer函数的参数就被确定了 示例：
package main import &amp;#34;fmt&amp;#34; func main() { DeferDef() DeferDef1() DeferDef2() } func DeferDef() { count := 1 defer fmt.Println(&amp;#34;defer executed, count的值为&amp;#34;,count) count++ fmt.Println(&amp;#34;before defer,count的值为&amp;#34;,count) } func DeferDef1() { count := 1 defer func(count int) { fmt.Println(&amp;#34;defer executed, count的值为&amp;#34;,count) }(count) count++ fmt.Println(&amp;#34;before defer,count的值为&amp;#34;,count) } func DeferDef2() { count := 1 defer func() { fmt.</description>
    </item>
    
    <item>
      <title>Go Etcd V3 Service Discovery</title>
      <link>http://dingjianhui.top/blog/2020/06/19/go-etcd-v3-service-discovery/</link>
      <pubDate>Fri, 19 Jun 2020 16:45:07 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/19/go-etcd-v3-service-discovery/</guid>
      <description>示意图 服务注册 1.服务提供者 创建服务 2.服务提供者 配置etcd 3.服务提供者 把服务注册到配置的etcd中 4.服务启动 5.服务关闭时反注册服务 (关闭时,回收资源)  package main import ( &amp;#34;context&amp;#34; &amp;#34;etcd-service/service/utils&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/google/uuid&amp;#34; &amp;#34;github.com/gorilla/mux&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;syscall&amp;#34; ) // 服务提供者  // service 服务注册  func main() { // 1. 创建服务 	serviceId := uuid.New().String() // 服务ID 	serviceName := &amp;#34;productDetailService&amp;#34; // 服务名 	serviceAddress := &amp;#34;192.168.123.178&amp;#34; // 服务地址 	servicePort := 8081 // 服务端口  router := mux.NewRouter() server := http.</description>
    </item>
    
    <item>
      <title>Go Cross Compile</title>
      <link>http://dingjianhui.top/blog/2020/06/05/go-cross-compile/</link>
      <pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/05/go-cross-compile/</guid>
      <description>linux set GOOS=linux set GOARCH=amd64 go build -o build/hugo main.go  windows set GOOS=windows set GOARCH=amd64 go build -o build/hugo.exe main.go   PS：环境变量参数参考：
 GOARCH: amd64, 386, arm, ppc64, … GOOS: linux, darwin, windows, netbsd, … </description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>http://dingjianhui.top/blog/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/goisforlovers/</guid>
      <description>&lt;p&gt;Hugo uses the excellent &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; &lt;a href=&#34;https://golang.org/pkg/html/template/&#34;&gt;html/template&lt;/a&gt; library for
its template engine. It is an extremely lightweight engine that provides a very
small amount of logic. In our experience that it is just the right amount of
logic to be able to create a good static website. If you have used other
template systems from different languages or frameworks you will find a lot of
similarities in Go templates.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>http://dingjianhui.top/blog/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
  </channel>
</rss>