<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Ding Jianhui 的个人博客 - 学习笔记</title>
    <link>http://dingjianhui.top/categories/golang/</link>
    <description>Recent content in golang on Ding Jianhui 的个人博客 - 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 07 Jul 2020 11:24:21 +0800</lastBuildDate>
    
	<atom:link href="http://dingjianhui.top/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Scheduler</title>
      <link>http://dingjianhui.top/blog/2020/07/07/go-scheduler/</link>
      <pubDate>Tue, 07 Jul 2020 11:24:21 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/07/go-scheduler/</guid>
      <description>地鼠用小车运着一堆待加工的砖。M就可以看作图中的地鼠，P就是小车，G就是小车里装的砖。 一图胜千言啊，弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。</description>
    </item>
    
    <item>
      <title>Go Grpc Stream</title>
      <link>http://dingjianhui.top/blog/2020/07/03/go-grpc-stream/</link>
      <pubDate>Fri, 03 Jul 2020 15:07:02 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/03/go-grpc-stream/</guid>
      <description>官方文档(基于golang语言)
流式RPC(服务端流式RPC、客户端流式RPC、双向流式RPC) https://www.grpc.io/docs/languages/go/basics
官方案例： https://github.com/grpc/grpc-go/tree/master/examples/route_guide
根据不同的业务场景, grpc 支持 4 种通信方式:
 客服端一次请求, 服务器一次应答 客服端一次请求, 服务器多次应答(流式) 客服端多次请求(流式), 服务器一次应答 客服端多次请求(流式), 服务器多次应答(流式)  为何要用流模式？
如果传输较大数据呢？会带来
1、数据包过大导致压力陡增
2、需要等待客户端包全部发送，才能处理以及响应
场景：假设我要从库里取 一批(x万到几十万)用户的积分.批量查询用户的积分
setp 1. 创建UserModel.proto syntax = &amp;#34;proto3&amp;#34;;package pb;message UserInfo { int32 user_id = 1; // 用户ID  int32 user_score = 2; // 用户积分 }setp 2. 创建User.proto syntax = &amp;#34;proto3&amp;#34;;package pb;import &amp;#34;UserModel.proto&amp;#34;;message UserScoreRequest { repeated UserInfo users = 1;}message UserScoreResponse { repeated UserInfo users = 1;}// 需要支持Restful API 参考Product.</description>
    </item>
    
    <item>
      <title>Protobuf Grammar (Protobu3)</title>
      <link>http://dingjianhui.top/blog/2020/07/01/protobuf-grammar/</link>
      <pubDate>Wed, 01 Jul 2020 13:45:32 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/01/protobuf-grammar/</guid>
      <description>Protobuf[1] 是一种语言中立、平台无关、可扩展的序列化数据的格式，可用于通信协议，数据存储等。
ProtoBuf 在序列化数据方面，它是灵活的、高效的。 相比于 XML 来说，ProtoBuf 更加小巧、更加快速、更加简单。 一旦定义了要处理的数据的数据结构之后，就可以利用 ProtoBuf 的代码生成工具生成相关的代码。 甚至可以在无需重新部署程序的情况下更新数据结构。 只需使用 ProtoBuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。
ProtoBuf 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等 领域的语言无关、平台无关、可扩展的序列化结构数据格式。
 Message 定义 在 Protobuf 中，所有结构化的数据都被称为 message。 假设你想要查询某个接口，这个接口需要传递些参数关键字和分页参数（当前页和每页记录数）， 那么我们就可以把这些参数都定义成一个对象，用 Protobuf 的话说就是定义一个 message。
如下：我们有一个服务为通过商品ID来获取商品的库存, 那么我们需要定义商品ID请求参数prod_id,定义库存响应字段prod_stock
syntax=&amp;#34;proto3&amp;#34;;package services;message ProdRequest { int32 prod_id = 1; // 传入的商品ID }message ProdResponse { int32 prod_stock = 1; // 响应的商品库存 }service ProdService { rpc GetProdStock (ProdRequest) returns (ProdResponse); // 通过商品ID获取商品库存方法 } syntax = &amp;quot;proto3&amp;quot;; 指定了整个 .proto 文件使用 Protobuf3 解析，否则默认会使用 Protobuf2 解析，必须将其放置在文件的第一行。 ProdRequest 这个 message 指定了1个数据字段，数据字段定义由 Field Types 数据类型 + Field Names 字段名 = Field Numbers 编号组成。 service 定义了 RPC 服务  字段类型   基础类型</description>
    </item>
    
    <item>
      <title>Go Grpc Gateway</title>
      <link>http://dingjianhui.top/blog/2020/06/30/go-grpc-gateway/</link>
      <pubDate>Tue, 30 Jun 2020 14:53:25 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/30/go-grpc-gateway/</guid>
      <description>前言 grpc很棒-支持多种语言来构建rpc服务,快速、易于使用、带宽高效， 但是我们仍然希望提供供传统的RESTful JSON API，兼容老系统
通常我们把rpc用作内部通信，而使用RESTful Api进行外部通信
服务器收到Http请求后grpc-gateway把他转换成grpc处理，然后以JSON格式返回
安装  安装 Protocol buffer 编译器(protoc) V3版本 https://github.com/protocolbuffers/protobuf/releases 安装 Protocol buffer 编译器的 Go插件 (protoc-gen-go) go get github.com/golang/protobuf/protoc-gen-go 安装 Protocol buffer 编译器的插件-grpc-gateway go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway 安装 Protocol buffer 编译器的插件-swagger go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger  使用 1. 使用Protocol buffer定义gRPC服务 server/pbfiles/Prod.proto:  syntax=&amp;#34;proto3&amp;#34;;package services;message ProdRequest { int32 prod_id =1; //传入的商品ID }message ProdResponse{ int32 prod_stock=1;//商品库存 }service ProdService { rpc GetProdStock (ProdRequest) returns (ProdResponse);}2. 添加google.api.http annotation 到 *.proto 文件中 可以将文件拷至 server/pbfiles中，也可以引用外部资源的方式 server/pbfiles/Prod.</description>
    </item>
    
    <item>
      <title>Go Grpc Quick Start</title>
      <link>http://dingjianhui.top/blog/2020/06/28/go-grpc-quick-start/</link>
      <pubDate>Sun, 28 Jun 2020 13:47:36 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/28/go-grpc-quick-start/</guid>
      <description>对于分布式系统而言,不同的服务分布在不同的节点上,一个服务要完成自己的功能经常需要调用其他服务的接口,比如典型的微服务架构。 通常这种服务调用方式有两种,一种是发送HTTP请求的方式,另一种则是RPC的方式,RPC是Remote Procedure Call(远程过程调用)的简称, 可以让我们像调用本地接口一样使用远程服务。相比HTTP调用,RPC的方式至少在以下几个方面有优势
  传输效率
RPC可以自定义TCP报文,基于TCP协议进行通信,比如dubbo;同时也支持使用HTTP2协议进行通信,比如gRPC。这相比传统的HTTP1.1协议报文体积会更小,传输效率会更高。
  性能消耗
RPC框架通常自带高效的序列化机制,序列化和反序列化耗时更低,序列化后的字节数通常也更小。
  负载均衡
RPC框架通常自带负载均衡策略,而HTTP请求要做负载均衡需要外部应用如Nginx的支持。
  服务治理
下游服务新增,重启,下线时能自动通知上游使用者,而HTTP的方式需要事先通知并修改相关配置。
  grpc介绍 gRPC是由Google开发并开源的RPC框架,它具有以下特点
  语言中立
支持C,Java,Go等多种语言来构建RPC服务,这是gRPC被广泛的应用在微服务项目中的重要原因,因为不同的微服务可能用不同的语言构建。
  基于HTTP/2协议
支持双向流,消息头压缩,单TCP的多路复用,服务端推送等,这些特性使得gRPC更加适用于移动场景下的客户端和服务端之间的通信。
  基于IDL定义服务
编写.proto文件即可生成特定语言的数据结构、服务端接口和客户端Stub。
  支持Protocol Buffer序列化
Protocol Buffer是由Google开发的一种数据序列化协议(类似于XML、JSON、Hession),平台无关,压缩和传输效率高,语法简单,表达能力强。
  使用前的准备工作   安装go
  安装 Protocol buffer 编译器(protoc) V3版本 https://github.com/protocolbuffers/protobuf/releases
  安装 Protocol buffer 编译器的 Go插件 (protoc-gen-go) go get github.com/golang/protobuf/protoc-gen-go
Google Protocol Buffer( 简称 Protobuf)</description>
    </item>
    
    <item>
      <title>Go Etcd Simple Config Center</title>
      <link>http://dingjianhui.top/blog/2020/06/26/go-etcd-simple-config-center/</link>
      <pubDate>Fri, 26 Jun 2020 15:50:48 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/26/go-etcd-simple-config-center/</guid>
      <description>简易示意图 Confd 一款高可用统一配置管理工具(go写的)
Step 1. 构建Confd镜像(使用go镜像) [tintin@localhost ttphp]$ ls etcd etcds tools [tintin@localhost ttphp]$ mkdir build [tintin@localhost ttphp]$ mkdir build/confd [tintin@localhost ttphp]$ cd build/confd/ [tintin@localhost confd]$ vi Dockerfile Dockerfile 参考文档
https://github.com/kelseyhightower/confd/blob/master/docs/installation.md
FROM1.14.4-alpine3.12 as confdARG CONFD_VERSION=0.16.0ADD https://github.com/kelseyhightower/confd/archive/v${CONFD_VERSION}.tar.gz /tmp/RUN apk add --no-cache \  bzip2 \  make &amp;amp;&amp;amp; \  mkdir -p /go/src/github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  cd /go/src/github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  tar --strip-components=1 -zxf /tmp/v${CONFD_VERSION}.tar.gz &amp;amp;&amp;amp; \  go install github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  rm -rf /tmp/v${CONFD_VERSION}.</description>
    </item>
    
    <item>
      <title>Go Binary Search Tree</title>
      <link>http://dingjianhui.top/blog/2020/06/24/go-binary-search-tree/</link>
      <pubDate>Wed, 24 Jun 2020 18:04:15 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/24/go-binary-search-tree/</guid>
      <description>二叉查找树(binary search tree) 特征：
二叉查找树，也称二叉搜索树，或二叉排序树。 要么是一颗空树，要么就是具有如下性质的二叉树：
（1） 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； （2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； （3） 任意节点的左、右子树也分别为二叉查找树； （4） 没有值相等的节点  1. 动态创建节点 func AddNode(tree *BSTree, root *BSTree) *BSTree { if root == nil { return tree } // 根节点 与 新节点对比 	// 新节点比 根节点大 放入右节点 	// 新节点比 根节点小 放入左节点 	if tree.Node &amp;gt; root.Node { root.RightNode = AddNode(tree,root.RightNode) } else if tree.Node &amp;lt; root.Node { root.LeftNode = AddNode(tree,root.LeftNode) } else { return root } return root } 2.</description>
    </item>
    
    <item>
      <title>Go Defer 的使用</title>
      <link>http://dingjianhui.top/blog/2020/06/24/go-defer-used/</link>
      <pubDate>Wed, 24 Jun 2020 09:04:03 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/24/go-defer-used/</guid>
      <description>defer介绍 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数 （为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。
常用于释放某些已分配的资源、关闭数据库连接、断开Socket连接、解锁一个加锁的资源
关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。
三个简单的规则：
1.defer定义时,defer函数的参数就被确定了 示例：
package main import &amp;#34;fmt&amp;#34; func main() { DeferDef() DeferDef1() DeferDef2() } func DeferDef() { count := 1 defer fmt.Println(&amp;#34;defer executed, count的值为&amp;#34;,count) count++ fmt.Println(&amp;#34;before defer,count的值为&amp;#34;,count) } func DeferDef1() { count := 1 defer func(count int) { fmt.Println(&amp;#34;defer executed, count的值为&amp;#34;,count) }(count) count++ fmt.Println(&amp;#34;before defer,count的值为&amp;#34;,count) } func DeferDef2() { count := 1 defer func() { fmt.</description>
    </item>
    
    <item>
      <title>Go Etcd V3 Service Discovery</title>
      <link>http://dingjianhui.top/blog/2020/06/19/go-etcd-v3-service-discovery/</link>
      <pubDate>Fri, 19 Jun 2020 16:45:07 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/19/go-etcd-v3-service-discovery/</guid>
      <description>示意图 服务注册 1.服务提供者 创建服务 2.服务提供者 配置etcd 3.服务提供者 把服务注册到配置的etcd中 4.服务启动 5.服务关闭时反注册服务 (关闭时,回收资源)  package main import ( &amp;#34;context&amp;#34; &amp;#34;etcd-service/service/utils&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/google/uuid&amp;#34; &amp;#34;github.com/gorilla/mux&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;syscall&amp;#34; ) // 服务提供者  // service 服务注册  func main() { // 1. 创建服务 	serviceId := uuid.New().String() // 服务ID 	serviceName := &amp;#34;productDetailService&amp;#34; // 服务名 	serviceAddress := &amp;#34;192.168.123.178&amp;#34; // 服务地址 	servicePort := 8081 // 服务端口  router := mux.NewRouter() server := http.</description>
    </item>
    
    <item>
      <title>Go Strings Byte Rune</title>
      <link>http://dingjianhui.top/blog/2020/07/14/go-strings-byte-rune/</link>
      <pubDate>Sat, 06 Jun 2020 15:29:25 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/14/go-strings-byte-rune/</guid>
      <description>什么是string string 是不可变的字节序列,采用utf8编码的 字节切片(slice), 因此用len函数获取到的长度并不是字符个数，而是字节个数。 for循环遍历输出的也是各个字节。
a := &amp;#34;Randal&amp;#34;; for i := 0; i &amp;lt; len(a); i++ { fmt.Printf(&amp;#34;%x &amp;#34;, a[i]) fmt.Printf(&amp;#34;%c &amp;#34;, a[i]) } // 输出结果 52 61 6e 64 61 6c a := &amp;#34;中国&amp;#34;; fmt.Println(len(a)) for i := 0; i &amp;lt; len(a); i++ { fmt.Printf(&amp;#34;%x &amp;#34;, a[i]) } for i := 0; i &amp;lt; len(a); i++ { fmt.Printf(&amp;#34;%c &amp;#34;, a[i]) } // 输出结果 6 E4 B8 AD E5 9B BD ä¸­å½ 什么是rune？ rune是int32的别名，代表字符的Unicode编码，采用4个字节存储， 将string转成rune就意味着任何一个字符都用4个字节来存储其unicode值， 这样每次遍历的时候返回的就是unicode值，而不再是字节了，这样就可以解决乱码问题了</description>
    </item>
    
    <item>
      <title>Go Cross Compile</title>
      <link>http://dingjianhui.top/blog/2020/06/05/go-cross-compile/</link>
      <pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/05/go-cross-compile/</guid>
      <description>linux set GOOS=linux set GOARCH=amd64 go build -o build/hugo main.go  windows set GOOS=windows set GOARCH=amd64 go build -o build/hugo.exe main.go   PS：环境变量参数参考：
 GOARCH: amd64, 386, arm, ppc64, … GOOS: linux, darwin, windows, netbsd, … </description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>http://dingjianhui.top/blog/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/goisforlovers/</guid>
      <description>&lt;p&gt;Hugo uses the excellent &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; &lt;a href=&#34;https://golang.org/pkg/html/template/&#34;&gt;html/template&lt;/a&gt; library for
its template engine. It is an extremely lightweight engine that provides a very
small amount of logic. In our experience that it is just the right amount of
logic to be able to create a good static website. If you have used other
template systems from different languages or frameworks you will find a lot of
similarities in Go templates.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>http://dingjianhui.top/blog/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
  </channel>
</rss>