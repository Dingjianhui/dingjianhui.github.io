<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ding Jianhui 的个人博客 - 学习笔记</title>
    <link>http://dingjianhui.top/</link>
    <description>Recent content on Ding Jianhui 的个人博客 - 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 20 Jul 2020 17:42:49 +0800</lastBuildDate>
    
	<atom:link href="http://dingjianhui.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Struct Default Value</title>
      <link>http://dingjianhui.top/blog/2020/07/20/go-struct-default-value/</link>
      <pubDate>Mon, 20 Jul 2020 17:42:49 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/20/go-struct-default-value/</guid>
      <description>传参时，不改变属性默认值时就不传该参数
比如php中
public function addLog($log_type,$log_content,$admin_id,$admin_name,$type = 2) { ...... } 调用
$this-&amp;gt;log-&amp;gt;addLog(0,&amp;quot;编辑角色 -- 该角色不存在&amp;quot;,$this-&amp;gt;admin_id,$this-&amp;gt;admin_name); $type就没有传  Golang中无法在参数中设置默认值，只能
 提供一个初始化函数，所有的字段都做为参数， 如果不需要的时候传该类型的零值，这把复杂度暴露给调用者； 提供多个初始化函数，针对每个场景都进行内部默认值设置。  高阶玩法 src/Object/User.go
package Object type User struct { UserId int UserName string UserAge int } // 初始化User对象 userAttr 设置属性值的函数体 func NewUser(userAttr ...UserAttr) *User { user := new(User) UserAttrs(userAttr).Apply(user) return user } src/Object/UserAttr.go
package Object type UserAttr func(user *User) // 用来定义User结构体的属性值函数  type UserAttrs []UserAttr // 执行设置属性值的函数 func (this UserAttrs) Apply(user *User) { // 遍历设置属性值的函数 	for _,withAttr := range this { withAttr(user) // 执行函数 	} } // 设置UserName属性的值 func WithUserName(userName string) UserAttr { return func(user *User) { user.</description>
    </item>
    
    <item>
      <title>Go Scheduler</title>
      <link>http://dingjianhui.top/blog/2020/07/07/go-scheduler/</link>
      <pubDate>Tue, 07 Jul 2020 11:24:21 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/07/go-scheduler/</guid>
      <description>调度逻辑 1. P、M、G的定义  P: processor(代表处理器核)，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数&amp;gt;=P的数量）； P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。 M: Work Thread(代表工作线程),在绑定有效的p后，进入schedule循环；而schedule循环的机制大致是从各种队列、 p的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到m，如此反复。 M并不保留G状态，这是G可以跨M调度的基础。 G: goroutine(代表协程)，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等； 另外G对象是可以重用的。  2. P和M的绑定关系  运行的M都必须绑定一个P P保存着一个协程G的队列 调度器还拥有一个全局的G队列 M从队列中提取G，并执行  3. 抢占式调度逻辑（找G的顺序）  1/61的几率在全局队列中找G，60/61的几率在本地队列找G 如果全局队列找不到G，从P的本地队列找G 如果找不到，从其他P的本地队列中窃取G(提高资源利用率) 如果找不到，则从全局队列中拿取一部分G到本地队列，这里拿取的“一部分”满足一个公式 n=min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))  4. 阻塞过程 如果当前的M执行的G调用syscall阻塞
 那么P会与M解绑 M负责执行阻塞的G P带着队列中的G绑定到新的M中，继续执行其他G  虽然当前G进入阻塞，但并没有影响到P去执行其他G
M执行的G阻塞操作返回后，由于没有了P，失去切换上下文执行后续逻辑的机会， 因此尝试获取新的P去执行，如果获取不到P，M就把当前G放入全局队列等待调度，自己置于休眠状态。
5. 线程自旋 线程自旋相对于线程阻塞，表现为循环执行指定的逻辑，而不进入阻塞状态。 在go的调度逻辑中，为了实现高性能的并发，如果全局队列和本地队列都为空， 绑定P的M没有G可以执行，会进入自旋状态等待新的G，不会进入阻塞状态休眠，减少了M的上下文切换成本。
注意只有绑定了P的M会进入自旋状态，因此最多会有GOMAXPROCS个自旋线程， 避免了浪费过多系统资源，其余未绑定的空闲M依然会进入休眠状态。
总结：go的协程调度就是 P将G合理的分配给某个M的过程  参考文章
 https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/ https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b https://lessisbetter.site/2019/03/10/golang-scheduler-1-history/ </description>
    </item>
    
    <item>
      <title>Go Grpc Stream</title>
      <link>http://dingjianhui.top/blog/2020/07/03/go-grpc-stream/</link>
      <pubDate>Fri, 03 Jul 2020 15:07:02 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/03/go-grpc-stream/</guid>
      <description>官方文档(基于golang语言)
流式RPC(服务端流式RPC、客户端流式RPC、双向流式RPC) https://www.grpc.io/docs/languages/go/basics
官方案例： https://github.com/grpc/grpc-go/tree/master/examples/route_guide
根据不同的业务场景, grpc 支持 4 种通信方式:
 客服端一次请求, 服务器一次应答 客服端一次请求, 服务器多次应答(流式) 客服端多次请求(流式), 服务器一次应答 客服端多次请求(流式), 服务器多次应答(流式)  为何要用流模式？
如果传输较大数据呢？会带来
1、数据包过大导致压力陡增
2、需要等待客户端包全部发送，才能处理以及响应
场景：假设我要从库里取 一批(x万到几十万)用户的积分.批量查询用户的积分
setp 1. 创建UserModel.proto syntax = &amp;#34;proto3&amp;#34;;package pb;message UserInfo { int32 user_id = 1; // 用户ID  int32 user_score = 2; // 用户积分 }setp 2. 创建User.proto syntax = &amp;#34;proto3&amp;#34;;package pb;import &amp;#34;UserModel.proto&amp;#34;;message UserScoreRequest { repeated UserInfo users = 1;}message UserScoreResponse { repeated UserInfo users = 1;}// 需要支持Restful API 参考Product.</description>
    </item>
    
    <item>
      <title>Protobuf Grammar (Protobu3)</title>
      <link>http://dingjianhui.top/blog/2020/07/01/protobuf-grammar/</link>
      <pubDate>Wed, 01 Jul 2020 13:45:32 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/07/01/protobuf-grammar/</guid>
      <description>Protobuf[1] 是一种语言中立、平台无关、可扩展的序列化数据的格式，可用于通信协议，数据存储等。
ProtoBuf 在序列化数据方面，它是灵活的、高效的。 相比于 XML 来说，ProtoBuf 更加小巧、更加快速、更加简单。 一旦定义了要处理的数据的数据结构之后，就可以利用 ProtoBuf 的代码生成工具生成相关的代码。 甚至可以在无需重新部署程序的情况下更新数据结构。 只需使用 ProtoBuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。
ProtoBuf 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等 领域的语言无关、平台无关、可扩展的序列化结构数据格式。
 Message 定义 在 Protobuf 中，所有结构化的数据都被称为 message。 假设你想要查询某个接口，这个接口需要传递些参数关键字和分页参数（当前页和每页记录数）， 那么我们就可以把这些参数都定义成一个对象，用 Protobuf 的话说就是定义一个 message。
如下：我们有一个服务为通过商品ID来获取商品的库存, 那么我们需要定义商品ID请求参数prod_id,定义库存响应字段prod_stock
syntax=&amp;#34;proto3&amp;#34;;package services;message ProdRequest { int32 prod_id = 1; // 传入的商品ID }message ProdResponse { int32 prod_stock = 1; // 响应的商品库存 }service ProdService { rpc GetProdStock (ProdRequest) returns (ProdResponse); // 通过商品ID获取商品库存方法 } syntax = &amp;quot;proto3&amp;quot;; 指定了整个 .proto 文件使用 Protobuf3 解析，否则默认会使用 Protobuf2 解析，必须将其放置在文件的第一行。 ProdRequest 这个 message 指定了1个数据字段，数据字段定义由 Field Types 数据类型 + Field Names 字段名 = Field Numbers 编号组成。 service 定义了 RPC 服务  字段类型   基础类型</description>
    </item>
    
    <item>
      <title>Go Grpc Gateway</title>
      <link>http://dingjianhui.top/blog/2020/06/30/go-grpc-gateway/</link>
      <pubDate>Tue, 30 Jun 2020 14:53:25 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/30/go-grpc-gateway/</guid>
      <description>前言 grpc很棒-支持多种语言来构建rpc服务,快速、易于使用、带宽高效， 但是我们仍然希望提供供传统的RESTful JSON API，兼容老系统
通常我们把rpc用作内部通信，而使用RESTful Api进行外部通信
服务器收到Http请求后grpc-gateway把他转换成grpc处理，然后以JSON格式返回
安装  安装 Protocol buffer 编译器(protoc) V3版本 https://github.com/protocolbuffers/protobuf/releases 安装 Protocol buffer 编译器的 Go插件 (protoc-gen-go) go get github.com/golang/protobuf/protoc-gen-go 安装 Protocol buffer 编译器的插件-grpc-gateway go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway 安装 Protocol buffer 编译器的插件-swagger go get github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger  使用 1. 使用Protocol buffer定义gRPC服务 server/pbfiles/Prod.proto:  syntax=&amp;#34;proto3&amp;#34;;package services;message ProdRequest { int32 prod_id =1; //传入的商品ID }message ProdResponse{ int32 prod_stock=1;//商品库存 }service ProdService { rpc GetProdStock (ProdRequest) returns (ProdResponse);}2. 添加google.api.http annotation 到 *.proto 文件中 可以将文件拷至 server/pbfiles中，也可以引用外部资源的方式 server/pbfiles/Prod.</description>
    </item>
    
    <item>
      <title>Generate Local Certificate</title>
      <link>http://dingjianhui.top/blog/2020/06/30/generate-local-certificate/</link>
      <pubDate>Tue, 30 Jun 2020 11:45:16 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/30/generate-local-certificate/</guid>
      <description>OpenSSL工具下载： 下载地址链接
windows环境 自签证书 进入 bin目录
  执行 openssl.exe
  执行 genrsa -des3 -out server.key 2048（会生成server.key,私钥文件）
  创建证书请求：req -new -key server.key -out server.csr（会生成server.csr）
其中common name 也就是域名
  删除密码 rsa -in server.key -out server_no_passwd.key
  执行x509 -req -days 365 -in server.csr -signkey server_no_passwd.key -out server.crt (会生成server.crt)
  使用自签CA、server、Client证书和双向认证 根证书（root certificate）是属于根证书颁发机构（CA）的公钥证书。 用以验证它所签发的证书（客户端、服务端）
创建CA公钥证书   执行 openssl.exe genrsa -out ca.key 2048 req -new -x509 -days 3650 -key ca.</description>
    </item>
    
    <item>
      <title>Go Grpc Quick Start</title>
      <link>http://dingjianhui.top/blog/2020/06/28/go-grpc-quick-start/</link>
      <pubDate>Sun, 28 Jun 2020 13:47:36 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/28/go-grpc-quick-start/</guid>
      <description>对于分布式系统而言,不同的服务分布在不同的节点上,一个服务要完成自己的功能经常需要调用其他服务的接口,比如典型的微服务架构。 通常这种服务调用方式有两种,一种是发送HTTP请求的方式,另一种则是RPC的方式,RPC是Remote Procedure Call(远程过程调用)的简称, 可以让我们像调用本地接口一样使用远程服务。相比HTTP调用,RPC的方式至少在以下几个方面有优势
  传输效率
RPC可以自定义TCP报文,基于TCP协议进行通信,比如dubbo;同时也支持使用HTTP2协议进行通信,比如gRPC。这相比传统的HTTP1.1协议报文体积会更小,传输效率会更高。
  性能消耗
RPC框架通常自带高效的序列化机制,序列化和反序列化耗时更低,序列化后的字节数通常也更小。
  负载均衡
RPC框架通常自带负载均衡策略,而HTTP请求要做负载均衡需要外部应用如Nginx的支持。
  服务治理
下游服务新增,重启,下线时能自动通知上游使用者,而HTTP的方式需要事先通知并修改相关配置。
  grpc介绍 gRPC是由Google开发并开源的RPC框架,它具有以下特点
  语言中立
支持C,Java,Go等多种语言来构建RPC服务,这是gRPC被广泛的应用在微服务项目中的重要原因,因为不同的微服务可能用不同的语言构建。
  基于HTTP/2协议
支持双向流,消息头压缩,单TCP的多路复用,服务端推送等,这些特性使得gRPC更加适用于移动场景下的客户端和服务端之间的通信。
  基于IDL定义服务
编写.proto文件即可生成特定语言的数据结构、服务端接口和客户端Stub。
  支持Protocol Buffer序列化
Protocol Buffer是由Google开发的一种数据序列化协议(类似于XML、JSON、Hession),平台无关,压缩和传输效率高,语法简单,表达能力强。
  使用前的准备工作   安装go
  安装 Protocol buffer 编译器(protoc) V3版本 https://github.com/protocolbuffers/protobuf/releases
  安装 Protocol buffer 编译器的 Go插件 (protoc-gen-go) go get github.com/golang/protobuf/protoc-gen-go
Google Protocol Buffer( 简称 Protobuf)</description>
    </item>
    
    <item>
      <title>Go Etcd Simple Config Center</title>
      <link>http://dingjianhui.top/blog/2020/06/26/go-etcd-simple-config-center/</link>
      <pubDate>Fri, 26 Jun 2020 15:50:48 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/26/go-etcd-simple-config-center/</guid>
      <description>简易示意图 Confd 一款高可用统一配置管理工具(go写的)
Step 1. 构建Confd镜像(使用go镜像) [tintin@localhost ttphp]$ ls etcd etcds tools [tintin@localhost ttphp]$ mkdir build [tintin@localhost ttphp]$ mkdir build/confd [tintin@localhost ttphp]$ cd build/confd/ [tintin@localhost confd]$ vi Dockerfile Dockerfile 参考文档
https://github.com/kelseyhightower/confd/blob/master/docs/installation.md
FROM1.14.4-alpine3.12 as confdARG CONFD_VERSION=0.16.0ADD https://github.com/kelseyhightower/confd/archive/v${CONFD_VERSION}.tar.gz /tmp/RUN apk add --no-cache \  bzip2 \  make &amp;amp;&amp;amp; \  mkdir -p /go/src/github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  cd /go/src/github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  tar --strip-components=1 -zxf /tmp/v${CONFD_VERSION}.tar.gz &amp;amp;&amp;amp; \  go install github.com/kelseyhightower/confd &amp;amp;&amp;amp; \  rm -rf /tmp/v${CONFD_VERSION}.</description>
    </item>
    
    <item>
      <title>Go Binary Search Tree</title>
      <link>http://dingjianhui.top/blog/2020/06/24/go-binary-search-tree/</link>
      <pubDate>Wed, 24 Jun 2020 18:04:15 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/24/go-binary-search-tree/</guid>
      <description>二叉查找树(binary search tree) 特征：
二叉查找树，也称二叉搜索树，或二叉排序树。 要么是一颗空树，要么就是具有如下性质的二叉树：
（1） 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； （2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； （3） 任意节点的左、右子树也分别为二叉查找树； （4） 没有值相等的节点  1. 动态创建节点 func AddNode(tree *BSTree, root *BSTree) *BSTree { if root == nil { return tree } // 根节点 与 新节点对比 	// 新节点比 根节点大 放入右节点 	// 新节点比 根节点小 放入左节点 	if tree.Node &amp;gt; root.Node { root.RightNode = AddNode(tree,root.RightNode) } else if tree.Node &amp;lt; root.Node { root.LeftNode = AddNode(tree,root.LeftNode) } else { return root } return root } 2.</description>
    </item>
    
    <item>
      <title>Go Defer 的使用</title>
      <link>http://dingjianhui.top/blog/2020/06/24/go-defer-used/</link>
      <pubDate>Wed, 24 Jun 2020 09:04:03 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/24/go-defer-used/</guid>
      <description>defer介绍 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数 （为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。
常用于释放某些已分配的资源、关闭数据库连接、断开Socket连接、解锁一个加锁的资源
关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。
三个简单的规则：
1.defer定义时,defer函数的参数就被确定了 示例：
package main import &amp;#34;fmt&amp;#34; func main() { DeferDef() DeferDef1() DeferDef2() } func DeferDef() { count := 1 defer fmt.Println(&amp;#34;defer executed, count的值为&amp;#34;,count) count++ fmt.Println(&amp;#34;before defer,count的值为&amp;#34;,count) } func DeferDef1() { count := 1 defer func(count int) { fmt.Println(&amp;#34;defer executed, count的值为&amp;#34;,count) }(count) count++ fmt.Println(&amp;#34;before defer,count的值为&amp;#34;,count) } func DeferDef2() { count := 1 defer func() { fmt.</description>
    </item>
    
    <item>
      <title>Go Etcd V3 Service Discovery</title>
      <link>http://dingjianhui.top/blog/2020/06/19/go-etcd-v3-service-discovery/</link>
      <pubDate>Fri, 19 Jun 2020 16:45:07 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/19/go-etcd-v3-service-discovery/</guid>
      <description>示意图 服务注册 1.服务提供者 创建服务 2.服务提供者 配置etcd 3.服务提供者 把服务注册到配置的etcd中 4.服务启动 5.服务关闭时反注册服务 (关闭时,回收资源)  package main import ( &amp;#34;context&amp;#34; &amp;#34;etcd-service/service/utils&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/google/uuid&amp;#34; &amp;#34;github.com/gorilla/mux&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;syscall&amp;#34; ) // 服务提供者  // service 服务注册  func main() { // 1. 创建服务 	serviceId := uuid.New().String() // 服务ID 	serviceName := &amp;#34;productDetailService&amp;#34; // 服务名 	serviceAddress := &amp;#34;192.168.123.178&amp;#34; // 服务地址 	servicePort := 8081 // 服务端口  router := mux.NewRouter() server := http.</description>
    </item>
    
    <item>
      <title>Centos Install Docker &amp; Docker Compose</title>
      <link>http://dingjianhui.top/blog/2020/06/17/centos-docker-install/</link>
      <pubDate>Wed, 17 Jun 2020 14:15:53 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/17/centos-docker-install/</guid>
      <description>安装文档-以官方文档为准
 官方文档 https://docs.docker.com/engine/install/centos/  Step 1 卸载旧版本 $ sudo yum remove docker \  docker-client \  docker-client-latest \  docker-common \  docker-latest \  docker-latest-logrotate \  docker-logrotate \  docker-engine Step 2 设置存储库 安装utils工具包 （依赖） 官方源信息 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 阿里云软件源 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  $ sudo yum install -y yum-utils $ sudo yum-config-manager \  --add-repo \  https://download.docker.com/linux/centos/docker-ce.repo Step 3 安装 docker 引擎 1.安装最新版本 $ sudo yum install docker-ce docker-ce-cli containerd.</description>
    </item>
    
    <item>
      <title>使用docker模拟etcd集群的创建</title>
      <link>http://dingjianhui.top/blog/2020/06/11/etcd-cluster-by-docker/</link>
      <pubDate>Thu, 11 Jun 2020 17:14:58 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/11/etcd-cluster-by-docker/</guid>
      <description>实际中部署集群 使用不同机器 或 docker swarm 或 k8s 来部署  Step 1 创建一个专门的docker网络 创建docker网络 (使用的是bridge,指定了子网) docker network create etcdnet --subnet 172.25.0.0/16 创建完后建议用户重新登录  [tintin@localhost ttphp]$ docker network create etcdnet --subnet 172.25.0.0/16 Step 2 创建两个节点 一个节点为etcd1,一个节点为etcd2 节点下各自创建 conf 和 data  [tintin@localhost ttphp]$ cd etcds/ [tintin@localhost etcds]$ mkdir etcd1 etcd2 [tintin@localhost etcds]$ mkdir etcd1/conf etcd1/data [tintin@localhost etcds]$ mkdir etcd2/conf etcd2/data Step 3 创建每个节点的配置文件 etcd1/conf/etcd.yml (etcd1节点的配置文件) vim etcd1/conf/etcd.yml  name: etcd1 data-dir: /etcd/data listen-client-urls: http://172.</description>
    </item>
    
    <item>
      <title>etcd环境搭建(基于docker)</title>
      <link>http://dingjianhui.top/blog/2020/06/11/etcd-install/</link>
      <pubDate>Thu, 11 Jun 2020 13:14:58 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/11/etcd-install/</guid>
      <description>etcd简介  A distributed, reliable key-value store for the most critical data of a distributed system
 etcd是一个高可用的键值存储系统 etcd是由CoreOS开发并维护的,灵感来自于 ZooKeeper 等。它使用Go语言编写 Github: https://github.com/etcd-io/etcd 官网: https://etcd.io  功能特点 简单：基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。 安全：可选 SSL 客户认证机制。 快速：每个实例每秒支持一千次写操作。 可信：使用 Raft 算法充分实现了分布式。  主要使用场景  主要用于共享配置 服务注册与发现 （Service Discovery） 分布式锁等  下载etcd并安装 下载地址：https://github.com/etcd-io/etcd/releases 我使用的方式是windows环境下载，然后上传至linux中 解压安装  [tintin@localhost tools]$ tar -zxvf etcd-v3.4.9-linux-amd64.tar.gz [tintin@localhost tools]$ mv etcd-v3.4.9-linux-amd64 ../etcd [tintin@localhost ttphp]$ cd ../etcd/ [tintin@localhost etcd]$ ls Documentation etcd etcdctl README-etcdctl.</description>
    </item>
    
    <item>
      <title>Go String Byte Rune</title>
      <link>http://dingjianhui.top/blog/2020/06/06/go-strings-byte-rune/</link>
      <pubDate>Sat, 06 Jun 2020 15:29:25 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/06/go-strings-byte-rune/</guid>
      <description>什么是string string 是不可变的字节序列,采用utf8编码的 字节切片(slice), 因此用len函数获取到的长度并不是字符个数，而是字节个数。 for循环遍历输出的也是各个字节。
a := &amp;#34;Randal&amp;#34;; for i := 0; i &amp;lt; len(a); i++ { fmt.Printf(&amp;#34;%x &amp;#34;, a[i]) fmt.Printf(&amp;#34;%c &amp;#34;, a[i]) } // 输出结果 52 61 6e 64 61 6c a := &amp;#34;中国&amp;#34;; fmt.Println(len(a)) for i := 0; i &amp;lt; len(a); i++ { fmt.Printf(&amp;#34;%x &amp;#34;, a[i]) } for i := 0; i &amp;lt; len(a); i++ { fmt.Printf(&amp;#34;%c &amp;#34;, a[i]) } // 输出结果 6 E4 B8 AD E5 9B BD ä¸­å½ 什么是rune？ rune是int32的别名，代表字符的Unicode编码，采用4个字节存储， 将string转成rune就意味着任何一个字符都用4个字节来存储其unicode值， 这样每次遍历的时候返回的就是unicode值，而不再是字节了，这样就可以解决乱码问题了</description>
    </item>
    
    <item>
      <title>Go Cross Compile</title>
      <link>http://dingjianhui.top/blog/2020/06/05/go-cross-compile/</link>
      <pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/05/go-cross-compile/</guid>
      <description>linux set GOOS=linux set GOARCH=amd64 go build -o build/hugo main.go  windows set GOOS=windows set GOARCH=amd64 go build -o build/hugo.exe main.go   PS：环境变量参数参考：
 GOARCH: amd64, 386, arm, ppc64, … GOOS: linux, darwin, windows, netbsd, … </description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-1/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-2/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-3/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-4/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-4/</guid>
      <description>主键索引与唯一索引的区别  主键不允许为空值，唯一索引列允许为空值 一个表只能有一个主键，但是可以有多个唯一索引 主键可以被其他表引用为外键，而唯一索引不可以 主键一定会创建一个唯一索引，但是唯一索引列不一定是主键 主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有着本质区别  </description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-5/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-6/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-7/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-7/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go Interview Finishing</title>
      <link>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-8/</link>
      <pubDate>Wed, 03 Jun 2020 13:14:17 +0800</pubDate>
      
      <guid>http://dingjianhui.top/blog/2020/06/03/go-interview-finishing-8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Basic HTML Elements</title>
      <link>http://dingjianhui.top/blog/basic-elements/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/basic-elements/</guid>
      <description>&lt;p&gt;The main purpose of this article is to make sure that all basic HTML Elements are decorated with CSS so as to not miss any possible elements when creating new themes for Hugo.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>http://dingjianhui.top/blog/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>About Hugo</title>
      <link>http://dingjianhui.top/blog/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/about/</guid>
      <description>Hugo is a static site engine written in Go.
It makes use of a variety of open source projects including:
 Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.
Setup Some fun facts about Hugo:
 Built in Go Loosely inspired by Jekyll Primarily developed by spf13 on the train while commuting to and from Manhattan. Coded in Vim using spf13-vim  Have questions or suggestions?</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>http://dingjianhui.top/blog/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/goisforlovers/</guid>
      <description>&lt;p&gt;Hugo uses the excellent &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; &lt;a href=&#34;https://golang.org/pkg/html/template/&#34;&gt;html/template&lt;/a&gt; library for
its template engine. It is an extremely lightweight engine that provides a very
small amount of logic. In our experience that it is just the right amount of
logic to be able to create a good static website. If you have used other
template systems from different languages or frameworks you will find a lot of
similarities in Go templates.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>http://dingjianhui.top/blog/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>http://dingjianhui.top/blog/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dingjianhui.top/blog/migrate-from-jekyll/</guid>
      <description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/▾ images/logo.png should become
▾ &amp;lt;root&amp;gt;/▾ static/▾ images/logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
  </channel>
</rss>